# TODO:
# - Many screens should be customizable
# - Should allow a screen after the final screen, so don't use `force_ask()`
metadata:
  title: Multiple signatures
  short: Signature
  documentation: https://docassemble.org/docs/recipes.html#multisignature
  example start: 1
  example end: 37
---
modules:  
  - docassemble.VirtualCourtToolbox.shortenURL
---
mandatory: True
code: |
  multi_user = True
---
mandatory: True
code: |
  process_action()  # Makes the `background_action`s possible, I think
  force_ask('unauthorized')
---
code: |
  emails_sent
  send_for_codefendant_signatures = True
---
code: |
  users[0].code
  signatories.gather()
  background_action('send_out_for_signature')
  emails_sent = True
---
id: gather signatories
code: |
  for codefendant in codefendants:
    signatories[codefendant.code] = codefendant
  signatories.gathered = True
---
id: send request for signatures
event: send_out_for_signature  # TODO: make plural
code: |
  log( 'a' )
  #for codefendant in codefendants.filter(is_local_signer=False):
  #  log( 'b' )
  #  if defined( codefendant.instanceName + '.send_method' ):
  #    log( 'c' )
  #    codefendant.notified
  for remote in remote_signers:
    log( 'b' )
    #if defined( remote.instanceName + '.send_method' ):
    #  log( 'c' )
    remote.notified
  log( 'd' )
  users[0].notified
  log( 'e' )
  # Let the background_action know this background action is
  # done. Don't do something else or send back any data.
  background_response()
---
comment: |
  =============================
  USER
  =============================
---
# Now set by the user outside of this flow
#code: |
#  users[0].signature_date = today()
---
# The status page will currently just say to wait for others to sign
code: |
  told_to_wait = True
  # Makes sure users[0].status is the only page the user can see.
  force_ask('users[0].status')
---
id: signature status
event: users[0].status
prevent going back: True
reconsider:
  - all_signatures_in
  - motion_to_dismiss_for_non_essential_eviction
  - final_form
question: |
  % if all_signatures_in:
  Your Eviction Moratorium has been signed.
  % else:
  Your Eviction Moratorium has not been signed by everyone yet.
  % endif
subquestion: |
  % if not all_signatures_in:
    % for codef in codefendants:
      % if defined( codef.instanceName + '.signature' ):
  ${ codef } has signed.

      % else:
  ${ codef } has not signed yet.

      % endif
    % endfor
  % else:
    % if len( codefendants ) > 1:
    ${ comma_and_list( codefendants )} have signed.
    % else:
      ${ codefendants[0] } has signed.
    % endif
  % endif
  
  ${ action_button_html('javascript:daRefreshSubmit()', label='Check again <i class="fas fa-sync-alt"></i>', size='lg') }
attachment code: motion_to_dismiss_for_non_essential_eviction
---
id: send user email
code: |
  send_email(to=users[0], template=initial_email_template)
  users[0].notified = True
---
id: user email before signatures
template: initial_email_template
subject: |
  Your Eviction Moratorium is out for signature.
content: |
  ${ users[0] },

  % if codefendants.number() == 1:
  We have e-mailed your codefendant to ask for a signature on the Eviction Moratorium.

  We will e-mail you when the codefendant has signed, but in the meantime you can [check the status].
  
  % else:
  I have e-mailed your codefendants to request that they sign the Eviction Moratorium.

  We will e-mail you when all the codefendants have signed.  You can check the status of your document to see who still has not signed.
  % endif

  [Check the status of the signatures]: ${ interview_url_action('status_page', code=users[0].code) }
---
# TODO: Is the generic one sufficient for the user object as well?
id: set interview's user id
code: |
  import random
  import string
  users[0].code = ''.join(random.choice(string.ascii_lowercase) for i in range(10))
---
id: ensure authorize user
event: status_page
code: |
  if action_argument('code') != users[0].code:
    force_ask('unauthorized')
  force_ask('users[0].status')
---
id: 404
event: unauthorized
code: |
  response('Page not found', response_code=404)
---
# Think this belongs with the QR code flow
# TODO: Wrong template for user?
code: |
  send_sms(task='send signature link', to=users[0].mobile_number, template=codefendants[i].sms_template)
---
id: if all signed send email
# Is requested when people check on the status of the signatures
code: |
  for codef in codefendants:
    if not codef.signed:
      all_signatures_in = False
      break
  else:
    final_email_sent
    all_signatures_in = True
---
# TODO: Check if user email is going to be required in this flow
code: |
  background_action('send_final_email')
  final_email_sent = True
---
event: send_final_email
code: |
  if defined( 'users[0].email' ) and users[0].email:
    send_email(to=users[0], template=final_email_template, attachments=motion_to_dismiss_for_non_essential_eviction)
  background_response()
---
id: all signed email template
reconsider:
  - final_form
template: final_email_template
subject: Your Eviction Moratorium has been signed by all parties
content: |
  ${ users[0] },

  Your Eviction Moratorium has now been signed by all of your codefendants.
  
  You can [tap to see the signed document](${ final_form.pdf.url_for() })
---
comment: |
  =============================
  Codefendants
  =============================
---
objects:
  #- who_proxy_sign_for: PeopleList.using(auto_gather=False)
  #- who_else_on_device: PeopleList.using(auto_gather=False)
  - local_signers: PeopleList.using(auto_gather=False)
---
#code: |
#  codefendants[i].is_proxy = False
#---
#code: |
#  codefendants[i].will_use_same_device = False
#---
#code: |
#  codefendants[i].is_local_signer = False
---
#code: |
#  # For users that will be signing on same device or who the user can sign for
#  if len(codefendants) > 0 and will_proxy_sign:
#    who_proxy_sign_for
#    #for proxied in who_proxy_sign_for:
#    #  proxied.is_proxy = True
#    
#  who_proxy_sign_for.gathered = True
#  set_proxy_signers = True
---
#code: |
#  # codefendants are co-signers
#  #---
#  # who_proxy_sign_for (defined through object checkboxes)
#  # codefendants the user has permission to sign for
#  #---
#  # who_else_on_device
#  # codefendants minus who_proxy_sign_for will sign on the user's device
#  #---
#  # local_signers
#  # A combo of the user and the two previous groups so we can collect all their signatures
#  #---
#  # remote_signers
#  # People who the user needs to send a link to
#---
#code: |
#  #  non_proxy = codefendants.filter( 'non_proxy', is_proxy = False )
#  #if len(non_proxy) > 0 and exist_other_local_signers:
#  #if len( codefendants.difference( who_proxy_sign_for )) > 0 and exist_other_local_signers:
#  #  who_else_on_device
#  #
#  #who_else_on_device.gathered = True
#  #
#  #set_others_on_device = True
##    for on_device in who_else_on_device:
##      on_device.will_use_same_device = True
##---
##---
##code: |
##  who_else_on_device = codefendants.difference( who_proxy_sign_for )
---
code: |
  local_signers_temp = DAList(auto_gather=False)
  #local_signers = DAList(auto_gather=False)
  local_signers_temp.extend( users )
  
  if len( codefendants ) > 0:
    if will_proxy_sign:
      local_signers_temp.extend( who_proxy_sign_for )

    codefendants_remain = ( not will_proxy_sign or  
        len( codefendants.difference( who_proxy_sign_for )) > 0)
    if codefendants_remain and exist_other_local_signers:
      local_signers_temp.extend( who_else_on_device )
  
  local_signers_temp.gathered = True
  local_signers = local_signers_temp
  
#  evaluate_what_other_signatures_will_be_on_this_device = True
#---
#code: |
#  local_signers = users + who_proxy_sign_for + who_else_on_device
---
#code: |
#  non_proxy = codefendants.difference( who_proxy_sign_for )
---
#code: |
#  local_signers = users + codefendants.filter(is_proxy = True) + codefendants.filter(will_use_same_device = True)
#  for local_signer in local_signers:
#    log( "local_signer:", 'console' )
#    log( local_signer, 'console' )
#    local_signer.is_local_signer = True
#  
#  ask_for_local_signers = True
---
id: proxy signer
question: |
  Are you signing for any of the codefendants?
yesno: will_proxy_sign
#yesno: who_proxy_sign_for.there_are_any
---
id: who will proxy
question: |
  Who will you be signing for?
fields:
  - no label: who_proxy_sign_for
    datatype: object_checkboxes
    choices:
      - codefendants
---
id: local co-signers
question: |
  Are any codefendants signing on your device?
yesno: exist_other_local_signers
---
id: device signers
question: |
  Who will be signing on your device?
fields:
  - no label: who_else_on_device
    datatype: object_checkboxes
    choices:
      - codefendants
    exclude:
      - who_proxy_sign_for
---
# Triggered with codefendants[i].notified
# TODO: put `.notified` outside of `if` statement
# If this is called from a background task and it results in
# an exception caused by an undefined variable, then .notified
# would not be set, but it would not cause a loop. It would error.
code: |
  log( '1' )
  if codefendants[i].send_method == 'text':
    log( '2' )
    message_sent_success = send_sms(task='send codefendant signature link', to=codefendants[i].mobile_phone,template=codefendants[i].sms_template)
    log( '3' )
    codefendants[i].notified = True
  else:
    message_sent_success = send_email(to=codefendants[i], template=codefendants[i].email_template)
    codefendants[i].notified = True
---
id: sms template multiuser
template: codefendants[i].sms_template
content: |
  Dear ${ codefendants[i] },
  Your signature needed on a document for ${ users[0] }.  
  ${ y.shortenedURL }
---
id: codefendant email
template: codefendants[i].email_template
subject: |
  Your signature needed on a document for ${ users[0] }
content: |
  Dear ${ codefendants[i] },

  You are requested to sign a sworn statement attesting that ${ users[0] } TODO: WHAT ARE THEY ATTESTING.

  [Tap here to see the document you are being asked to sign](${ motion_to_dismiss_for_non_essential_eviction.pdf.url_for() }).

  [Tap here to sign the thing](${ codefendants[i].sign_url })
---
# TODO: Change '.code' to '.signer_id'
# A randomized ID for the individual so the interview can tell who
# they are when they use the link to sign the document.
id: set interview's id for remaining individuals
generic object: Individual
code: |
  import random
  import string
  x.code = ''.join(random.choice(string.ascii_lowercase) for i in range(10))
---
id: shorten codefendant url
code: |
  y = shortenMe(codefendants[i].sign_url)
---
id: codefendant signature url
code: |
  codefendants[i].sign_url = interview_url_action('request_signature', code=codefendants[i].code)
---
id: signatories flow
event: request_signature
code: |
  log( 'here?' )
  # No new code gets run after a `force_ask`
  if action_argument('code') not in signatories:
    force_ask('unauthorized')
  codefendant = signatories[action_argument('code')]
  if codefendant.signed:
    force_ask(codefendant.instanceName + '.thanked')
  force_ask(codefendant.instanceName + '.willing_to_sign',
    codefendant.instanceName + '.signature',
    { 'recompute': [ codefendant.instanceName + '.signature_obtained' ] },
    codefendant.instanceName + '.thanked')
---
id: codefendant willing to sign
reconsider:
  - motion_to_dismiss_for_non_essential_eviction
  - final_form
question: |
  Are you willing to sign a statement attesting that ${ users[0] } TODO: WHAT ARE THEY ATTESTING?
subquestion: |
  You can [preview the statement](${ motion_to_dismiss_for_non_essential_eviction.pdf.url_for() }) now.

  If you are willing to sign, tap to continue.  On the next screen, you will provide your signature.
continue button field: codefendants[i].willing_to_sign
---
id: Codefendant signature
generic object: Person
question: |
  Sign your name
signature: x.signature
under: |
  ${ x }
---
id: thank codefendants
event: codefendants[i].thanked
reconsider:
  - all_signatures_in
  - motion_to_dismiss_for_non_essential_eviction
  - final_form
question: |
  Thank you for signing ${ users[0].possessive('Eviction Moratorium') }
subquestion: |
  If you would like a signed copy for your records, you can download or email it below.

  % if not all_signatures_in:
  Please note that not everyone has signed the document yet.
  % endif
  
  ${ motion_to_dismiss_for_non_essential_eviction }
attachment code: motion_to_dismiss_for_non_essential_eviction
---
only sets: codefendants[i].signature_obtained
code: |
  codefendants[i].signed = True
  codefendants[i].signature_date = today()
  codefendants[i].signature_obtained = True
---
# if signature_choice == 'this device':
#       for signature in signature_fields:
#         value(signature)    
#     # Check for Branch 2 or 3
#     elif signature_choice == 'phone':
#       saw_signature_qrcode
#       # User will click next. users[0].mobile_number will only be defined if they chose the texting option
#       if defined('users[0].mobile_number') and users[0].mobile_number and task_not_yet_performed('send signature link'): 
#         # They used the text option
#         send_sms(task='send signature link', to=users[0].mobile_number,template=interview_link)
#         signature_wait_screen
#         for signature in signature_fields:
#           value(signature)
#       else: # Branch 3: They used the QR Code. No special screen, just continue
#         for signature in signature_fields:
#           value(signature)
#       # Show the follow-up either way
#       if device().is_mobile:
#         #signed = False
#         #while not signed:
#         #  for signature in signature_fields:
#         #    signed = defined(signature) & signed
#         signature_phone_followup
#   basic_questions_signature_flow = True
# ---
# code: |
#   users[0]_signature_verification = users[0].signature
# ---
# id: basic questions intro screen
---
# Makes sure this is defined when the signer has not signed yet
code: |
  codefendants[i].signed = False
---
## TODO: Possibly replace with text that's useful, maybe underlined somehow
#code: |
#  codefendants[i].signature_date = "_________________"
#---
## TODO: Possibly replace with text that's useful, maybe underlined somehow
#code: |
#  codefendants[i].signature = "____________________________"
